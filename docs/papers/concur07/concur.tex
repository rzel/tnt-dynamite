\documentclass[orivec]{llncs}
\usepackage{verbatim}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{amsfonts, amssymb, amsmath}

\input{macros}
\input{mpsmacros}

\newtheorem{prop}{Proposition}

\title{Timed Mobile Systems}

\author{Andrew Hughes\thanks{Corresponding author.} and Mike Stannett}

\institute{Department of Computer Science, University of Sheffield, \\
Regent Court, 211 Portobello Street, Sheffield S1 4DP, UK. \\
	   \email{a.hughes@dcs.shef.ac.uk}
}

\begin{document}

\maketitle

\begin{abstract}

We present \emph{TNT}, a novel calculus combining explicit clocks and
run-to-completion semantics with mobility, and demonstrate its
suitability for modelling complex hierarachical systems with dynamic
topology.

\end{abstract}

\section{Introduction}
\label{introduction}

A standard feature of concurrent systems modelling is the use of
\emph{synchronisation} to model \emph{interaction}. Indeed, this is the
defining concept of CCS \cite{milner:ccs}. \AJH{In contrast,
calculi}{Calculi}\QUESTION{In contrast with what exactly?} that include
\emph{localities} -- for example the \emph{ambient calculus} \cite{amb}
-- also allow the notion of componentisation to be explicitly realised
by forming processes into a hierarchy. The inclusion of locality
naturally leads to \emph{mobility}, the ability of a system to change
its topological structure unilaterally. Consequently, the ambient
calculus and its analogues are well positioned to model distributed
systems in which resources can migrate from one location to another.

What tends to be absent from these models, however, is the notion of
behaviour also being governed by time, or at least, some notion of
workflow. Some calculi maintain \AJH{real}{continuous} time values
\cite{tccs,beaten:timing,brics:lee}, but the notion that work typically
occurs in stages in modelled only abstractly. For example, consider an
environment inhabited by the members of a factory team. The team
receives a series of tasks to execute, which require the team members to
communicate with one another. At some point, the first task is completed
and the team moves on to the next. Modelling this in a setting where the
number of workers cannot be predicted typically requires the use, either
of \emph{global} synchronisation, or else (which we reject) of an
infinite set of defining equations.

The idea of global synchronisation via \emph{clock signals} is made
explicit by various discrete timed process algebras, including TPL
\cite{hennessy:tpl}, PMC \cite{pmc}, CSA \cite{csa} and CaSE
\cite{case,norton05alg}. Our contribution is to combine the notions of
\emph{location}, \emph{clocks} and \emph{mobility} to create a calculus
capable of modelling dynamic componentised systems, where behaviour is
defined both by interactions between individual processes and by
responses to external stimuli, as represented by clock signals.  A
number of calculi \cite{lee:realtime,satoh:phd,webpi} have already
attempted to combine mobility with \AJH{real}{continuous} time
values\QUESTION{You mentioned that such systems existed earlier, using
refs 3--5. These are different refs, but it seems odd to repeat the same
fact as if it were different. Or is it \emph{actually} different to what
you mentioned before? They are different; continuous time + mobility,
not just continuous time}, but we believe the aggregation of mobility
and discrete clocks to be novel.

Our calculus, \emph{Typed Nomadic Time} (TNT) provides a framework for
modelling such systems, with practical
applicability very much in mind. The object of this
paper is to demonstrate its underlying formal theory, derived in part
from existing research in the area, via a description of its syntax,
operational semantics and type system. Our long term aim is to leverage
TNT as a foundation for creating concurrent systems within a
programmatic context. This will allow the specification of system interactions to be shifted directly from the
theoretical domain into an implementation backed by a formal
methodology, \MPS{and, in turn, facilitates the general industry shift
towards}{helping in turn to improve industrial adoption of}\QUESTION{You
changed the meaning here.} concurrent
techniques.

\section{Typed Nomadic Time}
\label{tnt}

In this section, we present the syntax, operational semantics and type
system of TNT. In creating this calculus, our aim is not to create ``yet
another process calculus,'' but rather a framework which allows
industrially relevant systems to be modelled in the simplest and most
elegant way possible. We have re-used well-established concepts where
appropriate.

\subsection{Syntax}

The formal syntax of TNT is shown in (\ref{eqn:tnt-syntax}), where
$\expr$ and $\exprb$ define possible process terms and $\ambop$ the
available mobility primitives. We assume a countable set of actions,
$\actions = \names \cup \conames \cup \{\tau\}$, ranged over by $\alpha$
and $\beta$, where the elements of $\names$ are drawn from an infinite
set of \emph{names}, and $\conames$ is the corresponding set of
\emph{co-names}, $\{\overline{a} \mid a \in \names\}$. $\timers$ is a
countably infinite set of \emph{clocks} over which $\sigma$ ranges,
while $m$ represents an arbitrary \emph{environ name}. In particular,
$m$ may be equal to the empty string, $\epsilon$, thus facilitating the
use of anonymous environs\footnote{A primary motivation for this is that
it allows TNT to be a conservative extension of CaSE. To obtain an
encoding for clock hiding, there must be a way of mapping the operator
to an equivalent environ}. $X$ ranges over a countably infinite set of
variables, which are used to bind process behaviour in recursive process
definitions.

\begin{equation}
  \begin{aligned}
    \expr, \exprb \quad \mathrel{::=} \quad &
      \nil  \mid
      \Omega \mid
      \Delta \mid
      \Delta_{\sigma} \mid
      \alpha . \expr  \mid
      \expr + \exprb \mid
      \expr \mathrel{\!|\!} \exprb \mid
      \timeout{\expr}{\sigma}{\exprb} \mid \\
    & \stimeout{\expr}{\sigma}{\exprb} \mid 
      \mu X . \expr \mid
      X \mid 
      \expr \setminus \vec{a} \mid
      \locv{m}{\expr}{\exprb}{\vec{\sigma}} \mid
      \ambop . \expr \\
   \ambop \quad \mathrel{::=} \quad & \tntin{m} \mid \tntout{m} \mid \tntopen{m} \mid
      \procin{\beta}{m} \mid \procout{\beta}{m} \mid \bin \mid
      \bout \mid \bopen
   \end{aligned}
   \label{eqn:tnt-syntax}
\end{equation}


At its heart, TNT is a conservative extension of Milner's CCS.
Specifically, within each environment lie processes which interact with
one another via \emph{handshake} synchronization; to proceed, one
process must emit an action as another simultaneously emits the
corresponding co-action.  This is something TNT shares with its
predecessor, CaSE, from which it also acquires the following features:

\begin{enumerate}
\item Multiple \emph{abstract clocks}, denoted by $\sigma, \rho, \dots$,
      which are interpreted not as quantitative values, but in a
      qualitative fashion as signals of recurring events.
\item Two \emph{timeout} operators, $\timeout{E}{\sigma}{F}$ and
      $\stimeout{E}{\sigma}{F}$, which allow the behaviour of
      processes to depend upon the occurrence of a particular clock
      signal.
\item Two \emph{timelock} operators, $\Delta$ and $\Delta_{\sigma}$,
      which prevent all clocks \AJH{(}{,}or a single
      clock, $\sigma$\AJH{)}{,} from ticking, respectively.
\item The concept of \emph{maximal progress} or, more generally,
      prioritisation.  A signal from a clock may be pre-empted by the
      existence of a process that engages in a higher priority
      transition.  In CaSE, the only such transition is the internal action,
      $\tau$, which results in processes performing the maximal amount
      of possible behaviour before allowing a clock to tick.
\item Encapsulation, realised in CaSE by the process of \emph{clock
      hiding}, which is analogous to the notion of hiding found in
      CSP \cite{hoare:csp78}.  This facilities the amalgamation of clock ticks
      from a child component into the cycle of its parent.
\end{enumerate}

\MPS{Clocks and the operators outlined above exist largely unchanged
(for the time being)}{The notion of clocks and their associated
operators are maintained verbatim} within TNT\MPS{their presence merely
allowing process behaviour to incorporate the notion of discrete time.
It is the two general concepts of encapsulation and
prioritisation that actually makes this valuable, by permitting}{,while \emph{encapsulation} and \emph{prioritisation},
which permit componentisation and synchronous event cycles respectively},
\MPS{and thus, it is these which TNT extends}{are extended}.

Within CaSE, encapsulation is implicitly realised by the notion of clock
hiding.  When a clock, $\sigma$, is hidden it appears indistinguishable
from an internal action to observers outside the scope of the hiding
operator.  \MPS{The effect of this, w}{W}hen combined with maximal
progress, \MPS{\DELTEXT is to have}{} an entire subsystem (defined by
the clock's scope) appear\MPS{\ADDTEXT}{s} equivalent to a single
process, with respect to the cycles of clocks with a wider scope.
\MPS{This means that, j}{J}ust as with processes, the subsystem
\MPS{must perform}{performs} the maximal amount of behaviour before the
\MPS{next of the more general clock ticks occurs}{clock ticks of the
parent occur}.

In TNT, we make this notion explicit by representing the boundaries of
the component within the syntax itself.  The effect of these is also
extended to processes, with interaction being disallowed between those
in separate environments.  In doing so, we look towards the existing
area of \emph{localities} \cite{obslocal,pawl} which have been used in
various ways in a number of existing calculi.  After surveying this area
at some length, we draw most of our inspiration from Cardelli and
Gordon's ambient calculus, which focuses primarily on this concept and
forms the framework for many of the results in this field.

Our localities or \emph{environs} are realised in the process
$\locv{m}{\expr}{\exprb}{\vec{\sigma}}$.  The environ is given a name
($m$), some behaviour ($\expr$), a security model in the form of a
`bouncer' ($\exprb$) and a set of clocks, $\vec{\sigma}$.  Environs incorporate clock hiding,
similar to CaSE's operator, with $\seml E / \sigma \semr \eqdef \loc{}{E}{\Omega}{\sigma}$.

The \MPS{name of the environ}{environ, $m$,} is used with TNT's mobility
primitives, \MPS{which are an extension of those present}{as} in
\MPS{the}{Cardelli and Gordon's} ambient calculus.  We maintain
\MPS{\DELTEXT the}{} $in\ m$, $out\ m$ and $open\ m$ primitives,
\MPS{\ADDTEXT}{but }represent\MPS{ing}{} them \MPS{instead as}{using}
the mnemonics $\tntin{m}$, $\tntout{m}$ and $\tntopen{m}$ to prevent
confusion with the names of actions.  \MPS{To this}{In addition}, we add two primitives for
process mobility, $\procin{\beta}{m}$ and $\procout{\beta}{m}$, which
allow objective mobility to occur via synchronization on the
action\MPS{\DELTEXT ,}{} $\beta$.

\AJH{\DELTEXT When movement occurs, a mobility transition is emitted
which forms part of a high priority set.  This, in turn, provides TNT's
extension of the concept of maximal progress to a more general one of
prioritisation.  The system at this stage is still simple; it merely
formalises the concept of including mobility within the same class of
functionality as internal behaviour and synchronisation, both of which
result in silent actions.}{}

Transitions are divided into three sets:

\begin{enumerate}
\item \emph{High priority transitions}, which includes $\tau$ and
      the mobility transitions, $\tin$, $\tout$ and $\topen$.  We denote
      these using the set, $\highpri$.
\item \emph{Low priority transitions}, which includes all
      clock transitions.
\item \emph{Independent transitions}, which arise from the occurrence of
      actions that don't pair up with a corresponding co-action (or
      vice versa).  These neither pre-empt nor inhibit any other
      transitions.  These are transitions with labels drawn from the set
      $\names \cup \conames$.
\end{enumerate}

If a process may emit a transition in $\highpri$, then low-priority
transitions are prevented from occurring.  This also applies to CaSE,
where $\highpri$ is simply $\{ \tau \}$.

Finally, TNT provides a method of security based on the research into
safe ambients \cite{sangiorgi:mobsafeambients}.  \emph{Grave
interferences} occur when two logically different mobility transitions may
occur at the same time, a scenario which clearly leads to two radically
different reductions.  These are unlike normal interferences, where more
than one action competes for synchronisation, and tend to represent
errors rather than an intentional notion of competition for resources.
They occur because, unlike actions, the mobility primitives in the
ambient calculus occur in isolation rather than in pairs.  Both safe
ambients and TNT solve this problem by introducing the equivalent of
co-names for mobility primitives, so that a similar synchronisation
process must take place before movement occurs.

In TNT, this is realised by \emph{bouncers}.  Named after the person who
restricts access to a night club, the bouncer is an additional property
of a environ which appears in the top right of the expression.  It has
no real behaviour of its own, but instead performs the job of protecting
the environ, essentially being a process with a more limited choice of
available constructs\footnote{This limited choice is only explicitly
imposed by the type system.  There is no restriction in the abstract
syntax.}.  The bouncer provides zero or more instances of a co-primitive
($\bin$, $\bout$ and $\bopen$), and as a result dictates which mobility
transitions may occur and their cardinality.

This implementation differs from that in existing calculi, such as
Sangiorgi's safe ambients, in specialising the process which may provide
these co-primitives and also in attaching it to the environ itself.
When a TNT environ moves, its bouncer moves with it and so an
association is maintained between the two which is not present where the
co-primitives are provided by an normal arbitrary process.  To maintain
this distinction between bouncers and normal processes, $\Omega$ is used
to represent a bouncer with no behaviour, as opposed to $\nil$.  The
effect of this addition is shown later in the type system of section
\ref{typesys}.

\subsection{Operational Semantics}

This section gives TNT an operational semantics in terms of a labelled
transition system, $(\mathcal{P}, \mathcal{L}, \rightarrow, s)$, defined
up to structural congruence.  $\proc$ is the set of states, $\labels$ the
alphabet $\actions \cup \timers \cup \mobprim$, $\rightarrow$ the
transition relation and $s$ the start state.  Transitions with labels in
$\actions$ are known as \emph{action transitions}, those in $\timers$ as
\emph{clock transitions} and those in $\mobprim$ as \emph{mobility
transitions}.  The transition relation, $\rightarrow \subseteq
\proc \times \labels \times \proc$ is defined in the tables that follow.
$E$, $F$ and $G$ range over process terms, $\sigma$ and $\rho$ over the
set of clocks ($\timers$), $\alpha$ over the set of actions
($\actions$), $h$ over $\highpri$, $a$ and $b$ over the actions
sans $\tau$, $\kappa$ over $\actions \cup \mobprim$
and $\gamma$ over the whole alphabet.  The semantics exhibit the
following properties:
\begin{prop}
the prioritisation property
i.e. $E \derives{\sigma}$ implies $E \nderives{h}$ 
\end{prop}
\begin{prop}
the time determinacy property i.e. $E \derives{\sigma} E'$ and $E
\derives{\sigma} E''$ implies $E' = E''$.
\end{prop}
Structural congruence is the least congruence relation that satisfies
the laws given in Table \ref{tab:structcong}, allowing structural
rearrangement and simplification of process terms. $\vec{A}$, $\vec{B}$
and $\vec{C}$ range over subsets of \actions, while $fn(E)$ denotes the
\emph{free names} of the process, $E$ (names that occur within $E$ which
are not bound by the restriction operator).  Notably, the rules allow:
 
\begin{itemize}
\item The set of restricted actions to be split between two parallel
      composed processes so that the restricted actions are not in the
      free names of the other process \textsf{(\ref{structrespar})}.
\item Multiple restriction operators to be combined into a single set
      \textsf{(\ref{structresres})}.
\end{itemize}

\begin{table}
  \caption{Semantics: Structural Congruence Laws}
 \label{tab:structcong}
 \vspace{-3mm}
  \shrule
  \begin{align}
   E + F & \equiv F + E \tag{StrSum1} \label{structsum1}
  \\
   E + (F + G) & \equiv (E + F) + G \tag{StrSum2} \label{structsum2}
   \\
    E \pc F & \equiv F \pc E \tag{StrPar1} \label{structpar1}
  \\
   E \pc (F \pc G) & \equiv (E \pc F) \pc G \tag{StrPar2} \label{structpar2}
 \\
    E \pc \nil & \equiv E \tag{StrIdent} \label{structident}
   \\
    \nil \setminus \vec{a} & \equiv \nil \tag{StrResRem}
   \label{structresremove}
   \\
    E \setminus \vec{A} \setminus \vec{B} & \equiv E \setminus \vec{A} \cup \vec{B}
   \tag{StrResRes} \label{structresres}
   \\
    (E \pc F) \setminus \vec{A} & \equiv (E \setminus \vec{B}) \pc (F
   \setminus \vec{C})^1 \tag{StrResPar} \label{structrespar}
\end{align}
\begin{align} 
   (1)\ & \vec{B} = \{b \in \vec{A} \pc b \not \in fn(F)\} \notag \\ 
   & \vec{C} = \{c \in \vec{A} \pc c \not \in fn(E)\} \notag
 \end{align} 
  \shrule
\end{table}

Table \ref{tab:casesubset} shows the subset of the semantics inherited
from CaSE, for which the reader is refered to \cite{case}.  The ones
presented here differ in that commutativity is now implied by the
presence of structural congruence and in the use of the restriction $E
\;|\; F \nderives{h}$ to enforce prioritisation.

\begin{table}
  \caption{Semantics: Rules Derived From CaSE \cite{case}}
 \label{tab:casesubset}
 \vspace{-3mm}
  \shrule
 \begin{center}
 \begin{tabular}{rc}
     \Rule{Idle}
     {-}
     {\nil \lderives{\sigma} \nil}
     {}
     &
     \Rule{Act}
     {-}
     {\alpha . E \derives{\alpha} E}
     {}
     \\[3ex]
     \Rule{Patient\ }
     {-}
     {a.E \derives{\sigma} a.E}
     {}
     &
     \Rule{Stall}
     {-}
     {\Delta_{\sigma} \derives{\rho} \Delta_{\sigma}}
     {\rho \ne \sigma}
     \\[3ex]
     \Rule{Sum1}
     {E \derives{\alpha} E^\prime}
     {E + F \derives{\alpha} E^\prime}
     {}
     &
     \Rule{Par1}
     {E \derives{\alpha} E^\prime}
     {E \;|\; F \derives{\alpha} E^\prime \;|\; F}
     {}
     \\[3ex]
     \Rule{Sum2}
     {E \derives{\sigma} E^\prime, F \derives{\sigma} F^\prime}
     {E + F \derives{\sigma} E^\prime + F^\prime}
     {}
     &
      \Rule{Par2}
      {E \derives{a} E^\prime,
        F \derives{\overline{a}} F^\prime}
      {E \;|\; F \derives{\tau} E^\prime \;|\; F^\prime}
      {}
     \\[3ex]
      \Rule{Par3}
      {E \derives{\sigma} E^\prime,
        F \derives{\sigma} F^\prime,
        E \;|\; F \nderives{h}}
      {E \;|\; F \derives{\sigma} E^\prime \;|\; F^\prime}
      {}
     &
      \Rule{FTO1}
      {E \nderives{h}}
      {\timeout{E}{\sigma}{F} \derives{\sigma} F}
      {}
     \\[3ex]
      \Rule{FTO2}
      {E \derives{\gamma} E'}
      {\timeout{E}{\sigma}{F} \derives{\gamma} E'}
      {\gamma \ne \sigma}
     &
      \Rule{STO1}
      {E \nderives{h}}
      {\stimeout{E}{\sigma}{F} \derives{\sigma} F}
      {}
     \\[3ex]
      \Rule{STO2}
      {E \derives{\kappa} E'}
      {\stimeout{E}{\sigma}{F} \derives{\kappa} E'}
      {}
     &
      \Rule{STO3}
      {E \derives{\rho} E'}
      {\stimeout{E}{\sigma}{F} \derives{\rho} \stimeout{E'}{\sigma}{F}}
      {\rho \ne \sigma}
     \\[3ex]
      \Rule{Rec}
      {E \derives{\gamma} E'}
      {\mu X.E \derives{\gamma} E' \{ \mu X.E / X\}}
      {}
      &
      \Rule{Res}
      {E \derives{\gamma} E'}
      {E \setminus a \derives{\gamma} E' \setminus a}
      {\gamma \ne a}
     \\
 \end{tabular}
  \end{center}
  \shrule
\end{table}

The semantics given in Table \ref{tab:hidingsubset} are similar to the
hiding rules given for CaSE, but are instead applied to the new
syntactic form used in TNT.  Also included are rules which allow the
mobility prefix to evolve, thus completing the semantics for the syntax
of $\expr$ and $\exprb$, and which link the structural congruence rules
into the labelled transition system.

\begin{table}
  \caption{Semantics: TNT Extensions}
  \label{tab:hidingsubset}
 \vspace{-3mm}
  \shrule
 \begin{center}
 \begin{tabular}{cc}
      \Rule{LHd1}
      {E \derives{\sigma} E'}
      {\locv{m}{E}{B}{\vec{\sigma}} \derives{\tau} \locv{m}{E'}{B}{\vec{\sigma}}}
      {\sigma \in \vec{\sigma}}
  &
        \Rule{LHd2}
      {E \derives{h} E'}
      {\locv{m}{E}{B}{\vec{\sigma}} \derives{h} \locv{m}{E'}{B}{\vec{\sigma}}}
      {}
  \\[3ex]
      \Rule{LHd3}
      {E \derives{\rho} E',
       E \nderives{\sigma}}
      {\locv{m}{E}{B}{\vec{\sigma}} \derives{\rho} \locv{m}{E'}{B}{\vec{\sigma}}}
      {\rho \not \in \vec{\sigma}, \sigma \in \vec{\sigma}}
&
      \Rule{Cap1}
      {-}
      {\ambop . E \derives{\ambop} E}
      {}
  \\[3ex]
  \Rule{Cap2}
  {-}
  {\ambop . E \derives{\sigma} \ambop . E}
  {}
&
     \Rule{SCong\ }
     {E \equiv E', E' \derives{\gamma} F', F' \equiv F}
     {E \derives{\gamma} F}
     {}
 \end{tabular}
  \end{center}
  \shrule
\end{table}

$LHd1$ provides the conversion of ticks emitted by the hidden clocks to
silent actions; if $E$ can perform a $\sigma$ transition, then it
performs a $\tau$ transition in a context where $\sigma$ is one of the
hidden clocks.  $LHd2$ and $LHd3$ simply allow the remaining action,
mobility and clock transitions to occur normally.  $Cap1$ and $Cap2$
define the evolution of the mobility prefix, allowing the mobility
primitive to execute and for clocks to idle over it, respectively.
Finally, $SCong$ states that if $E$ is structurally equivalent to
$E^\prime$ and $E^\prime$ can evolve to become $F^\prime$, which is
itself structurally equivalent to $F$, then $E$ can evolve via the same
transition to become $F$.

The remaining semantics focus on the provision of mobility.  Table
\ref{tab:locmobsubset} gives the rules required to move an environ
around the hierarchy.  $InLoc$ allows a $\tin$ transition to occur and
$n$ to move into $m$ if matching $\tntin{m}$ and $\bin$ transitions are
available from the process $\tntin{m}.E$ and bouncer, $B_1$.  $OutLoc$
gives the converse for $\tntout{m}.E$ and $\bout$, allowing a $\tout$
transition to occur and $n$ to move outside $n$.  Likewise,
$\tntopen{m}$ causes a $\topen$ transition to occur when both an
$\tntopen{m}$ and an $\bopen$ transition are available.  The named
environ, $m$, is destroyed and the two clock contexts unified.


\begin{table}
  \caption{Semantics: Environ Behaviour}
  \label{tab:locmobsubset}
 \vspace{-3mm}
  \shrule
 \begin{center}
 \begin{tabular}{c}
  \Rule{InEnv}
  {E \derives{\tntin{m}} E', B_1 \derives{\bin} B'_1}
  {\locv{n}{E}{B_2}{\vec{\sigma}} \;|\;
  \locv{m}{G}{B_1}{\vec{\rho}}
  \derives{\tin}
  \locv{m}{G \pc \locv{n}{E'}{B_2}{\vec{\sigma}}}{B'_1}{\vec{\rho}}}
  {}
  \\[3ex]
  \Rule{OutEnv\ \ }
  {E \derives{\tntout{m}} E', B_1 \derives{\bout} B'_1}
  {\locv{m}{G \pc \locv{n}{E}{B_2}{\vec{\sigma}}}{B_1}{\vec{\rho}}
  \derives{\tout}
  \locv{n}{E'}{B_2}{\vec{\sigma}} \pc
  \locv{m}{G}{B'_1}{\vec{\rho}}}
  {}
  \\[3ex]
  \Rule{Open}
  {E \derives{\tntopen{m}} E', B_1 \derives{\bopen} B'_1}
  {\locv{n}{E \;|\; \locv{m}{F}{B_1}{\vec{\sigma}}}{B_2}{\vec{\gamma}}
  \derives{\topen} 
  \locv{n}{E' \;|\; F}{B_2}{\vec{\gamma} \cup \vec{\sigma}}}
  {}
 \end{tabular}
  \end{center}
  \shrule
\end{table}

Finally, Table \ref{tab:procmobsubset} shows the semantics which relate
to how processes move between environs.  In both rules, $E$ moves due to
a mobility primitive which is part of $F$.  This occurs if
$\procin{a}{m}$ or $\procout{a}{m}$, $a$ and $\bin$ or $\bout$ transitions
take place, respectively.  An appropriate mobility transition ($\tin$
or $\tout$) is emitted as a result of this three-way synchronization.

\begin{table}
  \caption{Semantics: Process Mobility}
  \label{tab:procmobsubset}
 \vspace{-3mm}
  \shrule
 \begin{center}
 \begin{tabular}{c}
      \Rule{ProcIn\ }
      {E \derives{a} E',
  F \xderives{\procin{a}{m}} F',
       B_1 \derives{\bin} B'_1}
      {((E \pc G) \setminus \vec{b}) \pc F \pc 
  \locv{m}{H}{B_1}{\vec{\sigma}}
  \derives{\tin}
  {(G \setminus \vec{b}) \pc F' \pc \locv{m}{H \pc E'}{B'_1}{\vec{\rho}}}
  }
  {}
  \\[3ex]
      \Rule{ProcOut\ \ \ }
  {E \derives{a} E',
  F \xderives{\procout{a}{m}} F',
  B_1 \derives{\bout} B'_1}
  {\locv{m}{((E \;|\; G) \setminus \vec{b}) \pc F}{B_1}{\vec{\sigma}}
  \derives{\tout}
  {E' \pc \locv{m}{(G \setminus \vec{b}) \pc F'}{B'_1}{\vec{\sigma}}}
  }
  {}
 \end{tabular}
  \end{center}
  \shrule
\end{table}

Process mobility, in this form, is \emph{objective}.  The process which
emits one of the two new process mobility primitives synchronises with a
partner process on the given action, and it is this partner which
actually moves.  The partner will be a process in the same environ, due
to the scoping of actions described above.

Such behaviour is initially difficult to understand, but can be made
clearer with a simple example.  Take the process,

\begin{equation}
\procin{go}{m}.E \pc go.F \pc \lcloc{m}{\nil}{\sigma}
\end{equation}

\noindent where $E$ may perform $\procin{go}{m}$, but it
is $go.F$ that will actually move,

\begin{equation}
\procin{go}{m}.E \pc go.F \pc \lcloc{m}{\nil}{\sigma} \derives{\tin}
E \pc \lcloc{m}{F \pc \nil}{\sigma}
\end{equation}

\noindent with the continuation, $F$, continuing to evolve in the
environ $m$.  Process mobility in this objective form may still be used
to perform subjective movement.  As processes can fork, a process that
wishes to move can evolve into a situation where it is composed in
parallel with a new process that exhibits the required movement
primitive.  To demonstrate the converse, $out$, in the scenario
above, $F$ can be defined as

\begin{equation}
F \eqdef leave.F^\prime \pc \procout{leave}{m}
\end{equation}

\noindent where the process on the right moves the one on the left
outside $m$.  In context, this performs as follows:

\begin{equation}
E \pc \lcloc{m}{leave.F^\prime \pc \procout{leave}{m}.\nil \pc
 \nil}{\sigma} 
\derives{\tout}
E \pc F^\prime \pc \lcloc{m}{\nil \pc \nil}{\sigma}
\end{equation}

\noindent to give a final process which is very similar to the original.
More generally, subjective process movement may be encoded as

\begin{equation}
\seml in\ m\ F.E \semr \eqdef z.F \pc \procin{z}{m}.E
\end{equation}

\noindent where $F$ is the process that will move in to $m$, $E$ is
the continuation and $z$ is a new name that doesn't appear free in the
surrounding context.  The converse is pretty much the same:

\begin{equation}
\seml out\ m\ F.E \semr \eqdef z.F \pc \procout{z}{m}.E
\end{equation}

These definitions require the availability of $z$ as a new action name.
Subjective movement is safer on an ad-hoc basis where the surrounding
context is known.

Returning to the semantics, note that channels in $E$ may become
unrestricted due to the movement of the process to a different environ.
This is illustrated in the rules by $((E \pc G) \setminus \vec{b})$,
which becomes simply $G \setminus \vec{b}$ when $E$ changes position.
As a result, any names that were members of $\vec{b}$ and thus
restricted in $E$ are no longer in this situation following the movement
of the process.  Actions are scoped to individual environs, and the
names are unique, so $E$ can neither see the name in the old environ,
nor maintain its own copy.

\subsection{Type System}
\label{typesys}

This final section focuses on the specification of a simple type
system for the calculus, which fulfils two main goals:

\begin{enumerate}
\item Ensures the sanity of a given TNT construction, which is
  implicit in the examples above.  This is primarily achieved by
  ensuring that normal process primitives and the primitives used by
  bouncers remain distinct.  For example,
  $\tntin{n}.\bin.\nil$ should not be a valid bouncer,
  especially as $\tntin{n}$ suggests that the bouncer (and its environ)
  should move inside $n$.
\item Restrict mobility by type in addition to cardinality.  With the
  syntax and semantics alone, movement control is limited to how many
  times an environ may be entered or exited.  With the addition of a type
  system, these operations can be restricted to processes whose type
  allows the mobility transition to take place.
\end{enumerate}

Inspiration for the type system is taken for existing research on
schemes for the ambient calculus, specifically the notion of groups
presented in \cite{ambienttypes} and \cite{m3}.

Each process is a member of a group, which determines the use of the
mobility primitives.  Each group has a type\footnote{Or, more
  accurately, as groups are types themselves, it essentially has a
  type of a type or a \emph{kind}} composed of the following sets of
environ names:

\begin{itemize}
\item $\mathscr{R}$ -- Environs which may be \emph{resided} in
\item $\mathscr{O}$ -- Environs which may be \emph{opened}
\item $\mathscr{L}$ -- Environs which may be \emph{left}
\item $\mathscr{E}$ -- Environs which may be \emph{entered}
\end{itemize}

$\mathscr{L}$ and $\mathscr{E}$ form subsets of $\mathscr{R}$, as
clearly, if a process may enter or leave a environ, it must also be
able to reside within it.  As an example, consider the group
$(\{n\},\emptyset, \emptyset,\{n\})$.  Processes which are members of
this group may enter and reside in $n$, but, once there, they may not
leave.  They also lack the ability to destroy $n$.

Table \ref{tab:basictypes} presents the basic rules and the rudimentary
types used for the basic elements of the syntax, such as $\nil$.  As is
standard in the literature, the types are defined with respect to a type
environment, $\Gamma$.  On this note, the rule $Env$ simply states that
if $\xi$ of type $T$ is a member of $\Gamma$, then a typing derivation
$\vdash \xi : T$ may be made in the context of $\Gamma$.  This forms the
basis of all later rules.

\begin{table}
  \caption{Types: Basics}
  \label{tab:basictypes}
 \vspace{-3mm}
  \shrule
 \begin{center}
 \begin{tabular}{rc}
     \Rule{Env}
     {\xi : T \in \Gamma}
     {\Gamma \vdash \xi : T}
     {}
  &
  \Rule{Nil}
     {\Gamma \vdash g : Group}
     {\Gamma \vdash \nil : g}
     {}
  \\[3ex]
     \Rule{BNil}
     {-}
     {\Gamma \vdash \Omega : Bouncer}
     {}
     &
     \Rule{Stop}
     {\Gamma \vdash g : Group}
     {\Gamma \vdash \Delta : g}
     {}
     \\[3ex]
     \Rule{Stall}
     {\Gamma \vdash \sigma : Clock, g : Group}
     {\Gamma \vdash \Delta_\sigma : g}
     {}
     &
     \Rule{Act}
     {\Gamma \vdash \alpha : Act, E : g : Group}
     {\Gamma \vdash \alpha . E : g}
     {}
  \\[3ex]
     \Rule{Rec}
     {\Gamma \vdash E : g : Group}
     {\Gamma \vdash \mu X.E : g}
     {}
     &
     \Rule{Res}
     {\Gamma \vdash a : Name, E : g : Group}
     {\Gamma \vdash E \setminus a : g}
     {}
 \end{tabular}
  \end{center}
  \shrule
\end{table}

The remaining rules in Table \ref {tab:basictypes} provide types for the
processes.  Via $Nil$ and $Stop$, both $\nil$ and $\Delta$ are given a
type of $g$, where $g$ is a group.  The only precondition for these
derivations is that $g$ is typeable as a $Group$ in the environment,
$Gamma$.  Likewise, $\Omega$ can be typed as a $Bouncer$, thus
distinguishing it from normal processes, such as $\nil$.

The other rules are also relatively straightforward.  $Stall$ simply
says that $\Delta_{\sigma}$ may be typed as a process of group $g$ if
$\sigma$ is a clock.  $Act$ states that $\alpha.E$ is a process in $g$
if $\alpha$ is typeable as an action ($Act$, which includes names,
co-names and $\tau$) and $E$ is also typeable as a process in the same
group.  In the same vein, $Rec$ and $Res$ type recursive and restricted
processes respectively, if the constituent process, $E$, is already
typeable as a process.  In the case of $Res$, $a$ must be a name
($Name$) if the process is to be successfully typed.

In Table \ref{tab:operatortypes}, types are given to the composition of
processes using the binary operators for summation, parallel composition
and timeout.  All four are mostly identical, providing a type for the
process resulting from the combination of the operator with two other
processes, $E$ and $F$.  Each process is given a type, which must
be equivalent groups within the union of the two environments, $\Gamma$
and $\Gamma^\prime$.

\begin{table}
  \caption{Types: Operators}
  \label{tab:operatortypes}
 \vspace{-3mm}
  \shrule
 \begin{center}
 \begin{tabular}{c}
     \Rule{Sum}
     {\Gamma \vdash P : g,
      \Gamma^\prime \vdash P^\prime : g^\prime,
      \Gamma \cup \Gamma^\prime \vdash g = g^\prime : Group}
     {\Gamma \cup \Gamma^\prime \vdash P + P^\prime : g}
     {}
     \\[3ex]
     \Rule{Par}
     {\Gamma \vdash P : g,
      \Gamma^\prime \vdash P^\prime : g^\prime,
      \Gamma \cup \Gamma^\prime \vdash g = g^\prime : Group}
  {\Gamma \cup \Gamma^\prime \vdash P \mid P^\prime : g}
     {}
     \\[3ex]
     \Rule{FTO}
     {\Gamma \vdash P : g,
      \Gamma^\prime \vdash P^\prime : g^\prime,
      \Gamma \cup \Gamma^\prime \vdash \sigma : Clock,
      \Gamma \cup \Gamma^\prime \vdash g = g^\prime : Group}
     {\Gamma \cup \Gamma^\prime \vdash \timeout{P}{\sigma}{P^\prime} : g}
     {}
  \\[3ex]
  \Rule{STO}
     {\Gamma \vdash P : g,
      \Gamma^\prime \vdash P^\prime : g^\prime,
      \Gamma \cup \Gamma^\prime \vdash \sigma : Clock,
      \Gamma \cup \Gamma^\prime \vdash g = g^\prime : Group}
     {\Gamma \cup \Gamma^\prime \vdash \stimeout{P}{\sigma}{P^\prime} : g}
     {}
     \\[3ex]
     \Rule{BSum}
     {\Gamma \cup \Gamma^\prime \vdash B : Bouncer,
      \Gamma \cup \Gamma^\prime  \vdash B^\prime : Bouncer}
     {\Gamma \cup \Gamma^\prime \vdash B + B^\prime : Bouncer}
     {}
 \end{tabular}
  \end{center}
  \shrule
\end{table}

The only other issue worthy of note with respect to these rules is that
$FTO$ and $STO$ also require that $\sigma$ is typeable as a clock,
another restriction which simply makes explicit a number of issues
implied in the syntax.  Table \ref{tab:operatortypes} also includes
a summation rule for bouncers, which simply requires that each bouncer
is typeable as a $Bouncer$ under the union of the two type environments,
$\Gamma$ and $\Gamma^\prime$.

The types in Tables \ref{tab:basictypes} and \ref{tab:operatortypes}
provide the basis for the mobility types presented in Table
\ref{tab:mobilitytypes}, which form the focus of this type system.
$g(\mathscr{R})$, $g(\mathscr{O})$, $g(\mathscr{L})$ and
$g(\mathscr{E})$ represent the sets of environ names that form the
group, $g$.

\begin{table}
  \caption{Types: Mobility}
  \label{tab:mobilitytypes}
 \vspace{-3mm}
  \shrule
 \begin{center}
 \begin{tabular}{c}
     \Rule{Environ}
     {\Gamma \vdash m : Environ,
     \Gamma \vdash P : g : Group,
     \Gamma \vdash B : Bouncer,
     m \in g(\mathscr{R})}
     {\Gamma \vdash \loc{m}{P}{B}{\vec{\sigma}} : g}
     {}
  \\[3ex]
     \Rule{EnvIn}
     {\Gamma \vdash m : Environ,
  \Gamma \vdash P : g : Group,
  m \in g(\mathscr{E})}
     {\Gamma \vdash \tntin{m}.P : g}
     {}
     \\[3ex]
     \Rule{EnvOut\ \ }
     {\Gamma \vdash \loc{n}{\loc{m}{P}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group,
  m \in g(\mathscr{L}),
  n \in g(\mathscr{E})}
     {\Gamma \vdash \tntout{m}.P : g}
     {}
     \\[3ex]
     \Rule{Open}
     {\Gamma \vdash \loc{n}{P}{B_1}{\vec{\sigma}} : g : Group,
  \Gamma \vdash \loc{m}{Q}{B}{\vec{\sigma}} : h : Group,
  m \in g(\mathscr{O}),
  n \in h(\mathscr{E})}
     {\Gamma \vdash \tntopen{m}.P : g}
     {}
  \\[3ex]
     \Rule{ProcIn\ \ }
  {\Gamma \vdash a : Name,
  \Gamma \vdash \loc{n}{P \mid Q \mid \loc{n}{\nil}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group, 
  m \in g(\mathscr{E})}
     {\loc{n}{\procin{a}{m}.P \mid a.Q \mid \loc{n}{\nil}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group}
     {}  
  \\[3ex]
     \Rule{ProcOut\ \ \ \ }
  {\Gamma \vdash a : Name,
  \Gamma \vdash \loc{n}{\loc{m}{P \mid Q}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group, 
  m \in g(\mathscr{L}),
  n \in g(\mathscr{E})}
     {\Gamma \vdash \loc{n}{\loc{m}{\procout{a}{m}.P \mid a.Q}{B}{\vec{\sigma}}}{B_2}{\vec{\rho}} :
  g}
     {}  
 \end{tabular}
  \end{center}
  \shrule
\end{table}

$Environ$ is a fundamental rule, which links environs, bouncers, clocks
and processes.  If $m$ is a environ name ($Environ$), $P$ is a process
of type $g$ (where $g$ is a $Group$) and $B$ is a $Bouncer$, then the
process $P$ may be typed as $g$ while encapsulated within the environ
$m$, with its bouncer $B$.  The later rules rely on this to provide a
type for the existing environ.

$EnvIn$, $EnvOut$ and $Open$ are fairly similar, all pertaining to
whether a particular environ movement is typeable, based on the groups
of the processes within them.  $EnvIn$ states that if $m$ is a environ
name, and $P$ is a process typed with the group, $g$, then $P$ may be
prefixed with the $\tntin{m}$ mobility primitive if m is an element of
the set $g(\mathscr{E})$, where $g(\mathscr{E})$ is the set of environ
names which members of group $g$ may enter.

The $EnvOut$ rules differs from $EnvIn$ in that it provides a context
for the movement which will occur when $\tntout{m}$ is performed.  This
is necessary because, not only must the resulting process,
$\tntout{m}.P$, be able to leave $m$, but it must also be able to enter
the environ above, $n$.  This is unnecessary in $EnvIn$ as $P$ does not
leave the environ above.  These restrictions are enforced by requiring
that the group of $P$, $g$, has $m$ as an element of $g(\mathscr{L})$ (so
$P$ can leave $m$) and $n$ as an element of $g(\mathscr{E})$ (so $P$ can
enter $n$).

$Open$ has similar requirements.  $P$ is the process that performs the
mobility primitive, $\tntopen{m}$, which requires its group, $g$, to
contain $m$ in the set of environ names which may be opened.  However,
the destruction of $m$ also has an effect on processes located in $m$,
represented as $Q$.  As a result, $Q$ must have an appropriate group,
$h$, such that $Q$ can reside in the parent environ, $n$, after $m$ is
removed.  $ProcIn$ and $ProcOut$ are nearly identical to $EnvIn$ and
$EnvOut$; the main difference is that they must provide additional
contextual information (as well as requiring the typeability of the
name, $a$) in order to handle the involvement of two processes rather
than simply one.

The final table, \ref{tab:bouncertypes}, adds some simple rules to
complete the typing of the bouncers.  $BRec$ allows recursive bouncers
to be defined, while $BIn$, $BOut$ and $BOpen$ allow an existing
bouncer, $B$, to be prefixed with one of the three bouncer primitives
($\bin$, $\bout$ and $\bopen$).

\begin{table}
  \caption{Types: Bouncers}
  \label{tab:bouncertypes}
 \vspace{-3mm}
  \shrule
 \begin{center}
 \begin{tabular}{rc}
  \Rule{BRec}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \mu X.B : Bouncer}
  {}
  &
  \Rule{BIn}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bin .B : Bouncer}
  {}
  \\[3ex]
  \Rule{BOut}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bout .B : Bouncer}
  {}
  &
  \Rule{BOpen\ }
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bopen .B : Bouncer}
  {}
  \end{tabular}
  \end{center}
  \shrule
\end{table}

\section{Conclusions and Future Work}
\label{futurework}

This paper presented a novel combination of process synchronisation and
mobility with the concept of discrete time.  In the process, we
introduced the concept of synchronization-based objective process
mobility and specific security processes, which are believed to be new
to the field of process algebra.  The resulting process calculus is
expected to provide a sufficient framework to tackle the concepts
mentioned in the introduction.

With regard to future work, we have yet to prove that the observational
equivalence theory defined for CaSE remains a congruence when extended
with the three new mobility transitions and syntactic additions of TNT.  We
also intend to begin development on a tool, DynamiTE, which will allow
both simulation of TNT processes and a mapping of these onto Java
objects and its underlying concurrency model.  In the long term, we
intend to consider further extensions to the calculus.  One possibility
is the generalisation of the notion of bouncers to a general property
attachment mechanism for environs, so that environs can also have, for
example, associated stochastic measures.  In the type system, an
inferencing algorithm would be beneficial to avoid the current reliance
on a pre-populated type environment.

\subsection*{Acknowledgements}

We thank Simon Foster, Gerald L{\"u}ttgen, Barry Norton and Georg Struth
for their comments and suggestions.  This work is supported by a grant
from the Engineering and Physical Sciences Research Council ({EPSRC}).

\bibliographystyle{splncs}
\bibliography{literature}

\end{document}